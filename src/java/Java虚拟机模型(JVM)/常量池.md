# 常量池

常量池就是字节码文件的Constant pool部分，运行的时候加载到方法区(元空间)，也叫运行时常量池
```
Constant pool:
   #1 = Methodref          #2.#3          // java/lang/Object."<init>":()V
   #2 = Class              #4             // java/lang/Object
   #3 = NameAndType        #5.#6          // "<init>":()V
   #4 = Utf8               java/lang/Object
   #5 = Utf8               <init>
   #6 = Utf8               ()V
   #7 = Class              #8             // Test
   #8 = Utf8               Test
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               SourceFile
  #12 = Utf8               Test.java
```

## 常量池构成
包含编译期生成的字面量、符号引用，JDK 7后支持运行时动态新增常量（如 String.intern ()）

### 字面量 （Literal）
字面量是代码中直接书写的常量值，编译期即可确定，是最易理解的常量类型，对应 Java 代码中 “看得见的常量”。

| 类型                | 说明                                                                 | 示例                          |
|---------------------|----------------------------------------------------------------------|-------------------------------|
| 字符串字面量        | 双引号包裹的字符串（String 类型），是常量池最典型的常量              | `"hello"`、`"Java"`、`""`（空串） |
| 基本类型字面量      | 整数、浮点数、字符、布尔值（注意：`null` 不是字面量，但归为特殊常量） | `100`、`3.14f`、`'a'`、`true`  |
| 基本类型包装类常量  | 小范围基本类型包装类（如 Integer -128~127）会缓存到常量池（自动装箱） | `Integer.valueOf(50)`（缓存） |


```java
public class ConstantDemo {
    // 编译期字面量，全部进入运行时常量池
    private static final String STR = "hello"; // 字符串字面量
    private static final int NUM = 100;        // 整数字面量
    private static final char C = 'a';         // 字符字面量
    
    public static void main(String[] args) {
        String s = "Java"; // 字符串字面量入池
        int i = 3.14f;     // 浮点字面量入池
    }
}
```

### 符号引用（Symbolic Reference）
这是运行时常量池的**特有核心**，符号引用是编译期生成的“间接引用”（无法直接指向内存地址），JVM 类加载的“解析阶段”会将其转为**直接引用**（指向实际内存地址）。
符号引用包含以下四类：

| 类型                | 说明                                                                 | 示例                                  |
|---------------------|----------------------------------------------------------------------|---------------------------------------|
| 类/接口全限定名     | 类/接口的完整路径（包名+类名），用于定位类的字节码                     | `java.lang.String`、`com.example.User` |
| 字段的名称+描述符   | 类中字段的名称 + 字段类型的描述符（描述符是 JVM 对类型的简写）        | User 类的 `name` 字段：名称`name` + 描述符`Ljava/lang/String;` |
| 方法的名称+描述符   | 类中方法的名称 + 方法参数/返回值的描述符                             | String 的 `equals` 方法：名称`equals` + 描述符`(Ljava/lang/Object;)Z`（Z 代表布尔） |
| 方法句柄/调用点限定符 | JDK 7+ 新增，支持动态语言调用（如 invokedynamic 指令）                | 动态调用方法时的方法句柄引用          |


比如代码中调用 `String.equals(Object)` 方法，编译期无法知道该方法在内存中的实际地址，因此会在常量池存储：
- 方法所属类的全限定名：`java.lang.String`；
- 方法名：`equals`；
- 方法描述符：`(Ljava/lang/Object;)Z`（表示入参是 Object，返回值是 boolean）。
JVM 运行时解析阶段，会将这些符号引用转为指向 `equals` 方法实际内存地址的直接引用。

### 运行时新增

JDK 7 前常量池仅存储编译期常量，JDK 7 后支持运行时新增（如 `String.intern()`）

```java
   String s = new String("test"); // "test" 编译期入池，new 对象在堆
   String s2 = s.intern();        // 若常量池无"test"，则将堆中"test"引用加入常量池
```

intern() 会让常量池持有字符串的引用（JDK 7+）或字符串的副本（JDK 6），若滥用会导致字符串无法被 GC 回收，引发内存泄漏或无效占用。

1. JDK 6 内存泄漏
永久代中的字符串副本几乎无法被 GC 回收（除非对应的类被卸载，而类卸载在生产环境中极少发生）。即使堆中生成字符串的对象被回收，永久代的副本仍会一直占用内存，最终导致永久代内存泄漏。
2. JDK 7+ 内存无效占用
常量池存储的是堆字符串的引用，若这些字符串本是临时数据（比如一次性业务请求的动态字符串），但被 intern() 后，常量池会一直持有引用，导致堆中的字符串无法被 GC 回收，堆内存被无效占用，最终可能触发 OutOfMemoryError: Java heap space。