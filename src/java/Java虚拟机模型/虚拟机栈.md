# 虚拟机栈

Java虚拟机通过虚拟机栈的形式运行方法，虚拟机栈是一个后进先出（LIFO）栈结构，对应的是多个方法之间的调用逻辑。

虚拟机栈中的栈帧结构是对应方法内容的结构化设计，栈帧中的局部变量表是数据的“存储”模块，操作数栈是数据的“运算”模块。方法的运行本质是数据处理，也就是存取和运算。

方法调用其他方法，或者成员变量是对象的时候，栈帧存的是符号引用，运行时要转成直接引用，就是动态链接（支持多态），编译时就能确定的是静态链接，如静态方法。

当前方法执行完后，要回到调用者的哪个位置继续执行，需要提供返回地址，返回地址指向的就是当前方法的下一行代码执行的地址

![java_stack.png](java_stack.png)

## 局部变量表
TODO

## 操作数栈
TODO

## 动态链接
TODO

## 返回地址
TODO



## 虚拟机栈执行流程

### java代码
```java
public class StackTest {
    public static void main(String[] args) {
        StackTest stackTest = new StackTest();
        stackTest.run(3);
    }

    public int run(int d) {
        int a = 1;
        int b = 2;
        int c = a + b;
        int f = add(c, d);
        return f;
    }

    public int add(int a, int b) {
        return a + b;
    }
}

```

### 字节码
```
  public int run(int);
    descriptor: (I)I
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=6, args_size=2
         0: iconst_1
         1: istore_2
         2: iconst_2
         3: istore_3
         4: iload_2
         5: iload_3
         6: iadd
         7: istore        4
         9: aload_0
        10: iload         4
        12: iload_1
        13: invokevirtual #5                  // Method add:(II)I
        16: istore        5
        18: iload         5
        20: ireturn
      LineNumberTable:
        line 10: 0
        line 11: 2
        line 12: 4
        line 13: 9
        line 14: 18
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      21     0  this   Lcom/yggdrasil/learn/stack/StackTest;
            0      21     1     d   I
            2      19     2     a   I
            4      17     3     b   I
            9      12     4     c   I
           18       3     5     f   I

```

### 第一步：创建栈栈
当JVM调用`run(int d)`方法时，会创建一个栈帧并压入虚拟机栈，这个栈帧的核心组成如下：

| 栈帧组件       | 具体信息                                                                 |
|----------------|--------------------------------------------------------------------------|
| 局部变量表     | `locals=6`表示有6个槽位（slot），`args_size=2`表示方法参数有2个（实例方法默认第一个参数是`this`，第二个是传入的`int d`）：<br>- slot 0：`this`（当前`StackTest`实例）<br>- slot 1：方法参数`d`（int类型）<br>- slot 2：局部变量`a`（int类型）<br>- slot 3：局部变量`b`（int类型）<br>- slot 4：局部变量`c`（int类型）<br>- slot 5：局部变量`f`（int类型） |
| 操作数栈       | `stack=3`表示操作数栈的最大深度为3（执行过程中最多同时存3个操作数），用于临时存放指令的操作数和计算结果 |
| 动态链接       | 负责将字节码中的“符号引用”（如`#5`）解析为实际的方法内存地址（本次示例会触发该逻辑） |
| 方法返回地址   | 保存调用`run(int)`方法的代码位置（比如`main`方法中调用`run(10)`的下一条指令地址），方法执行完后回到该位置继续执行 |

### 第二步：执行指令

| 指令偏移 | 指令                | 操作含义                                                                 | 操作数栈变化                | 局部变量表变化                |
|----------|---------------------|--------------------------------------------------------------------------|-----------------------------|-------------------------------|
| 0        | iconst_1            | 将常量`1`压入操作数栈                                                   | [] → [1]                    | 无                            |
| 1        | istore_2            | 弹出栈顶的`1`，存入局部变量表slot2（对应变量`a`）                        | [1] → []                    | slot2 = 1（a=1）              |
| 2        | iconst_2            | 将常量`2`压入操作数栈                                                   | [] → [2]                    | 无                            |
| 3        | istore_3            | 弹出栈顶的`2`，存入局部变量表slot3（对应变量`b`）                        | [2] → []                    | slot3 = 2（b=2）              |
| 4        | iload_2             | 从局部变量表slot2取出`1`（a的值），压入操作数栈                           | [] → [1]                    | 无                            |
| 5        | iload_3             | 从局部变量表slot3取出`2`（b的值），压入操作数栈                           | [1] → [1, 2]                | 无                            |
| 6        | iadd                | 弹出栈顶两个int值（1和2），相加得到`3`，将结果压回操作数栈               | [1, 2] → [3]                | 无                            |
| 7        | istore        4     | 弹出栈顶的`3`，存入局部变量表slot4（对应变量`c`）<br>（注：slot≥4时用`istore + 偏移`格式） | [3] → []                    | slot4 = 3（c=3）              |
| 9        | aload_0             | 从局部变量表slot0取出`this`（当前实例），压入操作数栈                     | [] → [this]                 | 无                            |
| 10       | iload         4     | 从局部变量表slot4取出`3`（c的值），压入操作数栈                           | [this] → [this, 3]          | 无                            |
| 12       | iload_1             | 从局部变量表slot1取出`d`（方法传入的参数值，比如调用时传10则取10），压入操作数栈 | [this, 3] → [this, 3, d]    | 无                            |
| 13       | invokevirtual #5    | 调用`this`的`add(int, int)`方法（参数是3和d）：<br>1. 弹出栈顶3个值（this、3、d）<br>2. 执行`add`方法，得到返回值`result`<br>3. 将`result`压入操作数栈 | [this, 3, d] → [result]     | 无                            |
| 16       | istore        5     | 弹出栈顶的`result`，存入局部变量表slot5（对应变量`f`）                    | [result] → []               | slot5 = result（f=result）    |
| 18       | iload         5     | 从局部变量表slot5取出`result`（f的值），压入操作数栈                       | [] → [result]               | 无                            |
| 20       | ireturn             | 弹出栈顶的`result`作为方法返回值：<br>1. 销毁当前栈帧<br>2. 回到调用方的返回地址继续执行 | [result] → []（栈帧销毁）   | 无（栈帧销毁，局部变量表失效） |

### 动态链接
在指令`13: invokevirtual #5`中，`#5`是**符号引用**（指向常量池中的`add(II)I`方法名），动态链接的工作流程：
- 栈帧创建时，动态链接组件会关联当前类的常量池；
- 执行`invokevirtual`时，动态链接会将符号引用`#5`解析为`add(int, int)`方法在内存中的**直接引用**（实际地址）；
- 解析完成后，JVM才能真正调用到`add`方法的字节码。

> 补充：如果`add`方法是重写方法（比如子类重写父类的`add`），动态链接还会在运行时确定具体调用哪个类的`add`方法（这也是“动态链接”中“动态”的含义）。

### 方法返回地址
- 栈帧创建时，JVM会记录“调用方执行到的指令位置”（比如调用方是`main`方法，执行`int res = stackTest.run(10);`时，会记录这条语句的下一条指令地址）；
- 执行`20: ireturn`时：
    1. 将返回值（`result`）传递给调用方（赋值给`res`）；
    2. 销毁`run(int)`的栈帧（从虚拟机栈弹出）；
    3. 根据保存的返回地址，回到`main`方法的下一条指令继续执行。
  
### 总结
简单来说，JVM执行方法的过程，就是栈帧中“局部变量表（存数据）→ 操作数栈（做计算）→ 动态链接（调方法）→ 返回地址（回调用方）”的完整交互过程。


