# Java并发编程

## 核心技术关系图
![thread_tree](thread_tree.png)

## 技术索引
- 线程基础
  - 线程概念
    - 进程
      - 资源分配的基本单位
      - 独立的地址空间
      - 进程间通信(IPC)
    - 线程
      - CPU调度的基本单位
      - 共享进程资源
      - 轻量级进程
    - 并发
      - 多个任务交替执行
      - 单核CPU
    - 并行
      - 多个任务同时执行
      - 多核CPU
    - 上下文切换
      - 保存线程状态
      - 恢复线程状态
      - 切换成本
  - 线程创建方式
    - 继承Thread类
      - 重写run方法
      - 单继承限制
    - 实现Runnable接口
      - 函数式接口
      - 解耦任务与线程
      - 可多实现
    - 实现Callable接口
      - 有返回值
      - 可抛出异常
      - 配合FutureTask使用
    - 使用线程池
      - ExecutorService.submit()
      - 复用线程
      - 统一管理
    - 使用Lambda表达式
    - 使用匿名内部类
  - 线程生命周期
    - NEW(新建)
      - 创建线程对象
      - 未调用start()
    - RUNNABLE(可运行)
      - 就绪状态(Ready)
      - 运行状态(Running)
      - 操作系统线程状态
    - BLOCKED(阻塞)
      - 等待监视器锁
      - synchronized阻塞
    - WAITING(等待)
      - Object.wait()
      - Thread.join()
      - LockSupport.park()
    - TIMED_WAITING(超时等待)
      - Thread.sleep(time)
      - Object.wait(time)
      - Thread.join(time)
      - LockSupport.parkNanos()
      - LockSupport.parkUntil()
    - TERMINATED(终止)
      - run()方法执行完毕
      - 异常终止
  - 线程常用方法
    - start()
      - 启动线程
      - 只能调用一次
      - native方法
    - run()
      - 线程执行体
      - 直接调用不会启动新线程
    - sleep()
      - 线程休眠
      - 不释放锁
      - native方法
      - InterruptedException
    - yield()
      - 线程让步
      - 提示调度器
      - 不保证一定让步
    - join()
      - 等待线程结束
      - join(timeout)
      - InterruptedException
    - interrupt()
      - 中断线程
      - 设置中断标志
      - 不是强制终止
    - isInterrupted()
      - 检查中断状态
      - 不清除中断标志
    - interrupted()
      - 检查中断状态
      - 清除中断标志
      - 静态方法
    - setName()/getName()
    - setPriority()/getPriority()
      - 优先级1-10
      - MIN_PRIORITY(1)
      - NORM_PRIORITY(5)
      - MAX_PRIORITY(10)
    - setDaemon()/isDaemon()
      - 守护线程
      - 用户线程全部结束则JVM退出
      - 必须在start()前设置
    - getState()
      - 获取线程状态
    - isAlive()
      - 线程是否存活
    - currentThread()
      - 获取当前线程
      - 静态方法
  - 线程中断
    - 中断标志
    - 中断响应
    - InterruptedException处理
    - 中断策略
  - 线程异常处理
    - UncaughtExceptionHandler
    - setDefaultUncaughtExceptionHandler()
    - setUncaughtExceptionHandler()
  - 线程组
    - ThreadGroup
    - 线程的集合
    - 树形结构
- Java内存模型(JMM)
  - 主内存
  - 工作内存
  - 内存交互操作
    - lock(锁定)
    - unlock(解锁)
    - read(读取)
    - load(载入)
    - use(使用)
    - assign(赋值)
    - store(存储)
    - write(写入)
  - happens-before原则
    - 程序顺序规则
    - 监视器锁规则
    - volatile变量规则
    - 线程启动规则
    - 线程终止规则
    - 线程中断规则
    - 对象终结规则
    - 传递性规则
  - as-if-serial语义
  - 重排序
    - 编译器重排序
    - 指令级重排序
    - 内存系统重排序
  - 内存屏障
    - LoadLoad屏障
    - StoreStore屏障
    - LoadStore屏障
    - StoreLoad屏障
  - 并发编程三大特性
    - 原子性
      - 不可分割的操作
      - synchronized
      - Lock
      - CAS
    - 可见性
      - 线程间变量可见
      - volatile
      - synchronized
      - final
    - 有序性
      - 指令执行顺序
      - volatile
      - synchronized
- synchronized关键字
  - 使用方式
    - 修饰实例方法
      - 锁当前对象
    - 修饰静态方法
      - 锁当前类的Class对象
    - 修饰代码块
      - 锁指定对象
  - 实现原理
    - 对象头
      - Mark Word
      - 类型指针
    - Monitor
      - 监视器锁
      - ObjectMonitor
      - enter/exit
    - 字节码
      - monitorenter
      - monitorexit
  - 锁优化
    - 偏向锁
      - 偏向第一个获取锁的线程
      - 减少同一线程获取锁的开销
      - 偏向锁标志
      - 撤销偏向锁
    - 轻量级锁
      - CAS操作
      - Lock Record
      - 自旋
    - 重量级锁
      - 依赖OS的互斥量(Mutex)
      - 用户态到内核态切换
    - 锁升级
      - 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
      - 不可降级(JDK15后可降级)
    - 自旋锁
      - 避免线程阻塞
      - 适用于锁持有时间短
      - 自适应自旋
    - 锁粗化
      - 扩大锁的范围
      - 减少加锁解锁次数
    - 锁消除
      - JIT编译优化
      - 逃逸分析
      - 删除不必要的同步
  - 可重入性
    - 同一线程可多次获取同一锁
    - 重入计数
- volatile关键字
  - 特性
    - 保证可见性
    - 禁止指令重排序
    - 不保证原子性
  - 实现原理
    - 内存屏障
    - Lock前缀指令
    - 缓存一致性协议(MESI)
  - 使用场景
    - 状态标志
    - 双重检查锁定(DCL)
    - 单例模式
  - volatile写
    - StoreStore屏障
    - volatile写操作
    - StoreLoad屏障
  - volatile读
    - volatile读操作
    - LoadLoad屏障
    - LoadStore屏障
- CAS(Compare And Swap)
  - 概念
    - 比较并交换
    - 乐观锁
    - 无锁算法
  - 组成
    - 内存位置(V)
    - 预期值(A)
    - 新值(B)
  - 实现
    - Unsafe类
    - compareAndSwapInt()
    - compareAndSwapLong()
    - compareAndSwapObject()
    - CPU原子指令
      - cmpxchg
  - 问题
    - ABA问题
      - AtomicStampedReference
      - AtomicMarkableReference
      - 版本号机制
    - 循环时间长开销大
      - 自旋等待
    - 只能保证一个共享变量的原子性
      - AtomicReference
      - 组合对象
- Lock接口
  - Lock接口方法
    - lock()
    - unlock()
    - tryLock()
    - tryLock(timeout)
    - lockInterruptibly()
    - newCondition()
  - Lock vs synchronized
    - 灵活性更高
    - 可中断
    - 可超时
    - 可尝试获取锁
    - 支持多个条件变量
    - 需要手动释放
  - ReentrantLock
    - 可重入锁
    - 独占锁
    - 公平锁/非公平锁
      - 公平锁
        - 按申请顺序获取锁
        - 性能较低
      - 非公平锁
        - 可插队
        - 默认实现
        - 性能较高
    - 实现原理
      - 基于AQS
      - state变量
      - 同步队列
    - 条件变量
      - Condition
      - 条件队列
  - ReentrantReadWriteLock
    - 读写锁
    - 读锁(共享锁)
      - 多个线程可同时持有
    - 写锁(独占锁)
      - 只有一个线程可持有
    - 锁降级
      - 写锁降级为读锁
      - 持有写锁时获取读锁，再释放写锁
    - 锁升级
      - 不支持
    - 实现原理
      - 基于AQS
      - state高16位表示读锁
      - state低16位表示写锁
    - 公平性
      - 公平模式
      - 非公平模式
  - StampedLock
    - JDK8引入
    - 三种模式
      - 写锁(独占)
      - 悲观读锁(共享)
      - 乐观读(无锁)
    - 乐观读
      - tryOptimisticRead()
      - validate()
      - 不是锁
    - 锁转换
      - tryConvertToWriteLock()
      - tryConvertToReadLock()
      - tryConvertToOptimisticRead()
    - 不可重入
    - 不支持Condition
    - 性能优于ReadWriteLock
- AQS(AbstractQueuedSynchronizer)
  - 抽象队列同步器
  - 核心组成
    - state变量
      - volatile int
      - 同步状态
      - getState()
      - setState()
      - compareAndSetState()
    - FIFO队列
      - CLH队列变体
      - 双向链表
      - Node节点
    - ConditionObject
      - 条件队列
  - 同步模式
    - 独占模式(Exclusive)
      - 只有一个线程可获取
      - ReentrantLock
    - 共享模式(Shared)
      - 多个线程可同时获取
      - Semaphore
      - CountDownLatch
  - 核心方法
    - acquire()
    - release()
    - acquireShared()
    - releaseShared()
    - tryAcquire()
    - tryRelease()
    - tryAcquireShared()
    - tryReleaseShared()
  - 实现原理
    - 模板方法模式
    - 子类实现tryAcquire等方法
    - 入队
    - 出队
    - 自旋
    - 阻塞
    - 唤醒
  - Node节点
    - waitStatus
      - CANCELLED(1)
      - SIGNAL(-1)
      - CONDITION(-2)
      - PROPAGATE(-3)
      - 0(初始状态)
    - prev/next
    - thread
    - nextWaiter
- 线程通信
  - wait()/notify()/notifyAll()
    - Object类方法
    - 必须在synchronized中使用
    - 必须持有对象锁
    - wait()
      - 释放锁
      - 进入等待队列
      - 需要被唤醒
    - notify()
      - 唤醒一个等待线程
      - 随机选择
    - notifyAll()
      - 唤醒所有等待线程
    - 虚假唤醒
      - 使用while循环判断条件
  - Condition
    - Lock的条件变量
    - await()
      - 类似wait()
      - 释放锁
      - 进入条件队列
    - signal()
      - 类似notify()
      - 唤醒一个等待线程
    - signalAll()
      - 类似notifyAll()
    - awaitNanos()
    - awaitUntil()
    - 支持多个条件变量
    - 实现原理
      - ConditionObject
      - 条件队列
      - 与同步队列的转换
  - LockSupport
    - 线程阻塞工具类
    - park()
      - 阻塞当前线程
      - 不需要获取锁
    - parkNanos()
    - parkUntil()
    - unpark(thread)
      - 唤醒指定线程
    - 许可机制
      - 最多一个许可
      - 先unpark后park不会阻塞
    - 实现原理
      - Unsafe
      - PARK/UNPARK
  - 管道通信
    - PipedInputStream
    - PipedOutputStream
    - PipedReader
    - PipedWriter
  - Thread.join()
    - 等待线程结束
    - 基于wait/notify实现
- 线程池
  - Executor框架
    - Executor
      - execute()
    - ExecutorService
      - submit()
      - shutdown()
      - shutdownNow()
      - invokeAll()
      - invokeAny()
    - ScheduledExecutorService
      - schedule()
      - scheduleAtFixedRate()
      - scheduleWithFixedDelay()
    - AbstractExecutorService
    - ThreadPoolExecutor
    - ScheduledThreadPoolExecutor
    - Executors工具类
  - ThreadPoolExecutor
    - 核心参数
      - corePoolSize
        - 核心线程数
        - 即使空闲也保留
      - maximumPoolSize
        - 最大线程数
      - keepAliveTime
        - 非核心线程空闲存活时间
      - unit
        - 时间单位
      - workQueue
        - 任务队列
        - ArrayBlockingQueue
        - LinkedBlockingQueue
        - SynchronousQueue
        - PriorityBlockingQueue
        - DelayQueue
      - threadFactory
        - 线程工厂
        - 创建新线程
      - handler
        - 拒绝策略
        - AbortPolicy(默认)
        - CallerRunsPolicy
        - DiscardPolicy
        - DiscardOldestPolicy
        - 自定义RejectedExecutionHandler
    - 工作流程
      - 提交任务
      - 核心线程数判断
      - 队列判断
      - 最大线程数判断
      - 拒绝策略
    - 线程池状态
      - RUNNING
      - SHUTDOWN
      - STOP
      - TIDYING
      - TERMINATED
    - 常用方法
      - execute()
      - submit()
      - shutdown()
        - 平滑关闭
        - 不接受新任务
        - 等待已有任务完成
      - shutdownNow()
        - 立即关闭
        - 尝试中断正在执行的任务
        - 返回未执行的任务列表
      - isShutdown()
      - isTerminated()
      - awaitTermination()
      - prestartCoreThread()
      - prestartAllCoreThreads()
    - 监控方法
      - getTaskCount()
      - getCompletedTaskCount()
      - getPoolSize()
      - getActiveCount()
      - getLargestPoolSize()
  - 预定义线程池
    - FixedThreadPool
      - Executors.newFixedThreadPool()
      - 固定大小线程池
      - LinkedBlockingQueue
      - 可能导致OOM
    - CachedThreadPool
      - Executors.newCachedThreadPool()
      - 可缓存线程池
      - SynchronousQueue
      - maximumPoolSize为Integer.MAX_VALUE
      - 可能创建过多线程
    - SingleThreadExecutor
      - Executors.newSingleThreadExecutor()
      - 单线程线程池
      - LinkedBlockingQueue
      - 顺序执行
    - ScheduledThreadPool
      - Executors.newScheduledThreadPool()
      - 定时任务线程池
      - DelayedWorkQueue
    - WorkStealingPool
      - Executors.newWorkStealingPool()
      - JDK8引入
      - 基于ForkJoinPool
      - 工作窃取
  - 线程池实践
    - 合理配置线程数
      - CPU密集型: CPU核心数+1
      - IO密集型: CPU核心数*2
      - 混合型: 根据实际情况调整
    - 选择合适的队列
    - 自定义线程工厂
      - 命名线程
      - 设置守护线程
      - 设置优先级
    - 自定义拒绝策略
    - 监控线程池
    - 动态调整
      - setCorePoolSize()
      - setMaximumPoolSize()
      - setKeepAliveTime()
- ForkJoin框架
  - 分治算法
  - 工作窃取
  - ForkJoinPool
    - 线程池实现
    - 默认并行度为CPU核心数
  - ForkJoinTask
    - RecursiveTask
      - 有返回值
    - RecursiveAction
      - 无返回值
    - CountedCompleter
  - fork()
    - 异步执行子任务
  - join()
    - 等待子任务完成
  - invoke()
    - 同步执行
  - 工作窃取算法
    - 每个线程有自己的双端队列
    - 从队列头部获取任务
    - 从其他线程队列尾部窃取任务
  - 适用场景
    - 大任务可分解为小任务
    - 任务之间独立
    - 递归算法
- CompletableFuture
  - 异步编程
  - 组合式异步
  - 创建
    - supplyAsync()
    - runAsync()
    - completedFuture()
  - 转换
    - thenApply()
    - thenApplyAsync()
  - 消费
    - thenAccept()
    - thenRun()
  - 组合
    - thenCompose()
    - thenCombine()
  - 多个CompletableFuture
    - allOf()
    - anyOf()
  - 异常处理
    - exceptionally()
    - handle()
    - whenComplete()
  - 回调
    - thenAcceptBoth()
    - runAfterBoth()
    - applyToEither()
    - acceptEither()
    - runAfterEither()
  - 实现原理
    - 基于ForkJoinPool
    - 责任链模式
- Future模式
  - Future接口
    - get()
      - 阻塞获取结果
      - get(timeout)
    - cancel()
      - 取消任务
    - isCancelled()
    - isDone()
  - FutureTask
    - 实现RunnableFuture
    - 既是Runnable又是Future
    - 状态
      - NEW
      - COMPLETING
      - NORMAL
      - EXCEPTIONAL
      - CANCELLED
      - INTERRUPTING
      - INTERRUPTED
    - 使用场景
      - 异步计算
      - 配合线程池
- 并发工具类
  - CountDownLatch
    - 倒计数器
    - await()
      - 等待计数归零
    - countDown()
      - 计数减一
    - 实现原理
      - 基于AQS
      - 共享模式
    - 使用场景
      - 等待多个线程完成
      - 并发测试
  - CyclicBarrier
    - 循环屏障
    - await()
      - 等待其他线程到达屏障
    - 可重用
    - barrierAction
      - 所有线程到达后执行
    - 实现原理
      - 基于ReentrantLock和Condition
    - 使用场景
      - 多线程计算数据最后合并
  - Semaphore
    - 信号量
    - acquire()
      - 获取许可
    - release()
      - 释放许可
    - tryAcquire()
    - 实现原理
      - 基于AQS
      - 共享模式
    - 公平/非公平
    - 使用场景
      - 限流
      - 资源池
  - Exchanger
    - 数据交换
    - exchange()
      - 交换数据
      - 阻塞等待
    - 使用场景
      - 两个线程间数据交换
      - 校对工作
  - Phaser
    - JDK7引入
    - 分阶段的栅栏
    - register()
    - arriveAndAwaitAdvance()
    - arriveAndDeregister()
    - 动态调整参与线程数
    - 可重用
    - 使用场景
      - 多阶段任务
- 原子类
  - 基本类型原子类
    - AtomicBoolean
    - AtomicInteger
      - get()
      - set()
      - getAndSet()
      - compareAndSet()
      - getAndIncrement()
      - getAndDecrement()
      - getAndAdd()
      - incrementAndGet()
      - decrementAndGet()
      - addAndGet()
    - AtomicLong
  - 数组类型原子类
    - AtomicIntegerArray
    - AtomicLongArray
    - AtomicReferenceArray
  - 引用类型原子类
    - AtomicReference
    - AtomicStampedReference
      - 版本号
      - 解决ABA问题
    - AtomicMarkableReference
      - 标记
      - 解决ABA问题
  - 字段更新器
    - AtomicIntegerFieldUpdater
    - AtomicLongFieldUpdater
    - AtomicReferenceFieldUpdater
    - 基于反射
    - 字段必须是volatile
  - 累加器(JDK8)
    - LongAdder
      - 比AtomicLong性能更好
      - 高并发场景
      - 分段思想
    - LongAccumulator
    - DoubleAdder
    - DoubleAccumulator
  - 实现原理
    - 基于CAS
    - 自旋
    - Unsafe类
- 并发集合
  - ConcurrentHashMap
    - 线程安全的HashMap
    - JDK7实现
      - Segment分段锁
      - 每个Segment一个锁
      - 继承ReentrantLock
    - JDK8实现
      - CAS + synchronized
      - 锁桶(Node数组)
      - 红黑树
    - 不允许null key和null value
    - 核心方法
      - put()
      - get()
      - putIfAbsent()
      - remove()
      - size()
    - 扩容机制
      - 协助扩容
      - 多线程并发扩容
  - ConcurrentSkipListMap
    - 跳表实现
    - 有序Map
    - 非阻塞
  - ConcurrentSkipListSet
    - 基于ConcurrentSkipListMap
    - 有序Set
  - CopyOnWriteArrayList
    - 写时复制
    - 适用于读多写少
    - add()时复制数组
    - volatile数组引用
    - 迭代器弱一致性
    - 内存占用
  - CopyOnWriteArraySet
    - 基于CopyOnWriteArrayList
  - ConcurrentLinkedQueue
    - 非阻塞队列
    - 基于CAS
    - 无界队列
    - FIFO
    - 不允许null元素
  - ConcurrentLinkedDeque
    - 双端队列
  - BlockingQueue
    - 阻塞队列
    - 生产者-消费者模式
    - put()
      - 队列满时阻塞
    - take()
      - 队列空时阻塞
    - offer(timeout)
    - poll(timeout)
    - ArrayBlockingQueue
      - 有界队列
      - 数组实现
      - FIFO
      - 一把锁
    - LinkedBlockingQueue
      - 可选有界队列
      - 链表实现
      - FIFO
      - 两把锁(putLock/takeLock)
    - PriorityBlockingQueue
      - 优先级队列
      - 无界队列
      - 堆实现
      - 不允许null元素
    - DelayQueue
      - 延迟队列
      - 元素实现Delayed接口
      - 到期才能取出
      - 无界队列
    - SynchronousQueue
      - 同步队列
      - 不存储元素
      - 每个put必须等待take
      - 公平/非公平
    - LinkedTransferQueue
      - 融合了多种队列特性
      - transfer()
      - tryTransfer()
    - LinkedBlockingDeque
      - 双端阻塞队列
  - BlockingDeque
    - 双端阻塞队列接口
- ThreadLocal
  - 线程本地变量
  - get()
  - set()
  - remove()
  - initialValue()
  - withInitial()
  - 实现原理
    - ThreadLocalMap
      - Thread的成员变量
      - Entry数组
      - Entry继承WeakReference
    - key是ThreadLocal对象
    - value是实际值
  - 内存泄漏
    - key是弱引用
    - value是强引用
    - ThreadLocal对象被回收后
    - 必须调用remove()
  - 应用场景
    - 线程隔离
    - 保存上下文信息
    - 数据库连接
    - Session管理
  - InheritableThreadLocal
    - 可继承的ThreadLocal
    - 子线程可访问父线程的值
- 并发设计模式
  - 生产者-消费者模式
    - BlockingQueue实现
    - wait/notify实现
  - 读写锁模式
    - ReadWriteLock
    - 读多写少场景
  - Future模式
    - 异步调用
    - 获取结果
  - Master-Worker模式
    - 任务分发
    - 结果汇总
  - Guarded Suspension模式
    - 保护性暂停
    - 条件满足时执行
  - Balking模式
    - 条件不满足直接返回
  - Thread-Per-Message模式
    - 每个请求一个线程
  - Worker Thread模式
    - 线程池模式
  - Two-Phase Termination模式
    - 两阶段终止
    - 安全关闭线程
  - Producer-Consumer模式
  - Immutable模式
    - 不可变对象
    - 线程安全
- 并发编程最佳实践
  - 减少锁的范围
  - 减少锁的粒度
  - 用非阻塞数据结构替代阻塞
  - 无锁编程
    - CAS
    - ThreadLocal
    - 不可变对象
  - 避免死锁
    - 固定加锁顺序
    - 超时放弃
    - 死锁检测
  - 性能优化
    - 减少上下文切换
    - 合理设置线程数
    - 使用合适的并发工具
    - 减少锁竞争
  - 线程安全
    - 无状态
    - 不可变
    - 同步
    - 线程封闭
  - 活跃性问题
    - 死锁
      - 互斥
      - 持有并等待
      - 不可抢占
      - 循环等待
    - 活锁
      - 线程不断重试
      - 增加随机性
    - 饥饿
      - 线程无法获取资源
      - 优先级问题
  - 对象发布与逸出
    - 安全发布
    - 防止this逸出
- 并发工具与框架
  - Disruptor
    - 高性能队列
    - 环形缓冲区
    - 无锁设计
  - Akka
    - Actor模型
    - 消息传递
  - RxJava
    - 响应式编程
    - 观察者模式
  - Reactor
    - 响应式编程
  - Netty
    - 高性能网络框架
    - EventLoop
  - Guava并发工具
    - ListenableFuture
    - RateLimiter
    - Striped
- 并发问题排查
  - 死锁排查
    - jstack
    - jvisualvm
    - JConsole
    - 线程dump
  - CPU占用高
    - top -H
    - jstack
    - 定位线程
  - 线程状态分析
    - RUNNABLE
    - BLOCKED
    - WAITING
    - TIMED_WAITING
  - 活锁检测
  - 饥饿检测
  - 性能分析
    - JProfiler
    - YourKit
    - Arthas
- JDK并发新特性
  - JDK5
    - java.util.concurrent包
    - Lock
    - Executor框架
    - 并发集合
    - 原子类
  - JDK6
    - ConcurrentSkipListMap
    - ConcurrentSkipListSet
  - JDK7
    - ForkJoinPool
    - Phaser
    - TransferQueue
  - JDK8
    - CompletableFuture
    - StampedLock
    - LongAdder
    - 并行流
  - JDK9
    - Flow API
    - 响应式流
  - JDK10
    - 局部变量类型推断
  - JDK11
    - Epsilon GC
  - JDK12-17
    - 持续改进
  - JDK19
    - 虚拟线程(预览)
  - JDK21
    - 虚拟线程(正式)
    - 结构化并发
- 虚拟线程(JDK21)
  - 轻量级线程
  - 用户态线程
  - M:N调度
  - 高并发场景
  - Thread.ofVirtual()
  - Thread.startVirtualThread()
  - Executors.newVirtualThreadPerTaskExecutor()
  - 优势
    - 创建成本低
    - 内存占用小
    - 数百万级并发
  - 限制
    - 不适合CPU密集型
    - synchronized会固定(pinning)
  - 结构化并发
    - StructuredTaskScope

